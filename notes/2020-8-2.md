---
title: 【Leetcode Weekly Digest】August 2020 - Week 2
url: lc-2008
date: 2020-08-13 09:39:31
tags: 
- Leetcode

categories: 
- Coding

---

Leetcode Weekly Digest for 2nd Week of August 2020 (August 8th - August 14th)

[toc]

<!--more-->

## August 8th

**Keyword:** MergeSort and Count

### 775 Global And Local Inversions

> Given a permutation of 0 ~ n-1, Return true if and only if the number of global inversions is equal to the number of local inversions.

- **Difficulty:** Hard
- **My Solution:** MergeSort to find the global inversion, `extra inversion =  midPos - leftPtr + 1`
- **Official Solution:** Note that the given array is a **Permutation**, we can simply check `for i in A.size(): if (abs(A[i] - i) > 1) return false`

### 493 Reverse Pairs

> Count the number of reverse pairs. Given an array nums, we call `(i, j)` an important reverse pair if `i < j` and `nums[i] > 2*nums[j]`.

- **Difficulty:** Hard
- **Solution:** MergeSort through the vector, use a double pointer `i` to move according to `2*nums[j]`, for every right component, `mergePairsCnt += midPos - i + 1;`
- **Tricks**:
  1. `nums[i] / 2.0 <= nums[j]` to avoid overflow
  2. seperate the counting & mergesort procedure to improve readability

## August 9th

### 202 Happy Numbers

> determine if a number n is "happy". (will not loop endlessly)

- **Difficulty:** Easy
- **Solution:** Use an array to record the previous results

### 3 Longest Substring Without Repeating Characters

> find the length of the longest substring without repeating characters.

- **Difficulty:** Medium
- **Solution:** Sliding Window Optimized

If a substring `s[i:j]` from index `i` to `j - 1` is already checked to have no duplicate characters. We only need to check if `s[j]` is already in the substring `s[i:j]`

To check whether a char is in the substring, maintain a map from charater to its last occuring index and compare the index with the sliding window

Optimization: if `s[j]` have a duplicate in the range `[i, j)` with index `j'`, we don't need to increase `i` little by little. We can **skip** all the elements in the range `[i, j']` and let `i` to be `j' + 1` directly.

## August 10th

### 5 Longest Palindromic Substring

> Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

- **Difficulty:** Medium
- **Solution 1:** reverse and find the **longest common string** using DP (Slow and expensive 33% and 10%)
- **Solution 2:** Search from Middle
  Note that palindromics are mirrored, first find the middle position (only `2n-1` possibilities) and try expanding from inside

### 11 Container With Most Water

> Find two lines, which together with x-axis forms a container, such that the container contains the most water. ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

- **Difficulty:** Medium
- **Solution:** Two Pointer Approach: Search from Sides (inspiration from bubble sort)

At every step, we find out the area formed between them, update `maxarea` and _move the pointer pointing to the shorter line_ towards the other end by one step. (If we try to move the pointer at the longer line inwards, we won't gain any increase in area, since it is limited by the shorter line.)

## August 13th

### 119 Pascal Triangle II

> Return the kth row of the pascal triangle
> ![pascal triangle](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

- **Difficulty:** Easy
- **Solution:** Trivial Walking

### 6 Median Of Two Sorted Array

> 

- **Difficulty:** 
- **Solution:** 
